Andrew Callahan
report
03/22/2017

2/28 : spent 30 min setting up repository and making sure that everyone could push/pull

3/1 -> spent 2 hours setting up all the initial files and creating the giant makefile so we could have a way to compile as we code

3/4 -> spent 2 hours writing the board and knight class and getting it to compile and put a knight on the board

3/21 -> spent 2 hours finishing the bishop and pawn classes and ended up having to add a few functions to board including getTeam. Also wrote a main to test adding some pieces to the board and seeing where they are allowed to move.


Our repository, called "Cones of Dunshire" doesn't have the code I updated for the lab, but it has everything the group did up to the lab. We are going to push everything once we decide how to merge the things we worked on for this lab. The dropbox code is a copy of the repository with my changes.

I added the code to pawn.h, pawn.cpp, changes to: bishop.cpp, piece.h , piece.cpp, board.h, board.cpp, knight.h, knight.cpp

Specifically I wrote/majorly updated the functions:

pawn.cpp:
	setMoves 
		-implemented the function
	getAttacks
		-implemented the function
bishop.cpp:
	setMoves
		-added a check for a blocking piece, and checked if you can capture the blocking piece
piece.cpp:
	hasmoved (datamember and access functions)
		-added this data member to check if the pawns can move twice. It will also be useful for other things such as castling
board.cpp:
	getTeam
		-added this so that pieces can check the team of a piece that is blocking them to see if it can be captured
	updateMoves
		-added this to update the possible moves of all pieces, this should be called when the board is updated
knight.cpp:
	setMoves
		-added a check for the blocking piece to see if it is a different team


I then wrote a simple main program that adds some pieces to the board and then prints out where some of the pieces are allowed to move.
It creates some pawns,knights and a bishop and prints out where some of the pieces can move, showing that one of the pawns that is blocked is not allowed to move anywhere, whereas the pawn that isn't has some possible moves.

I set out to complete the pawn and king files. However, the king is way more difficult than any of the other pieces because the king is not allowed to move into check. This means that we will have to think about a way to figure out where the king is allowed to move without having to check all the attacks each time. I was thinking that we would create a new data structure (array?) that contains all the squares that are attacked and have the king check this each time it looks for the possible moves. Completing the pawn was also more complicated than I expected and I still haven't implemented the enpassant rule which would require adding a new data member to check if the pawn has just moved two squares so that other pawns can check if that pawn has passed the capture square by moving twice. 

Overall, we have a great start at implementing the game rules, we just have to finish up the more obscure types of moves/pieces and implement a simple two player chess game, then we can move on to creating the AI with that framework.  

Kyle has made good work on the SDL graphics, so we could reasonable get a graphical two player chess game going fairly soon.

My order of priorities is:

-Complete king and any other pieces that aren't done

-Add obscure rules such as castling/enpassant

-Write a main that tests it by allowing for a two player chess game

After that we can move on to the AI



